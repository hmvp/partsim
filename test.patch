### Eclipse Workspace Patch 1.0
#P Particle Simulator
Index: src/gdp/erichiram/partsim/Round.java
===================================================================
--- src/gdp/erichiram/partsim/Round.java	(revision 95)
+++ src/gdp/erichiram/partsim/Round.java	(working copy)
@@ -4,76 +4,100 @@
 
 package gdp.erichiram.partsim;
 
+import java.util.Collection;
+import java.util.LinkedList;
+
 /**
- * Keeps track of the rounds to make sure that threads do go 
- * to the next while there is work to be done in this one
- *
+ * Keeps track of the rounds to make sure that threads do go to the next while
+ * there is work to be done in this one
+ * 
  */
 public class Round {
-	
+
 	/**
 	 * the round number
 	 */
 	private volatile int round = Main.initialRound;
-	
+
 	/**
 	 * reference to main
 	 */
 	private final Main m;
-	
+
 	/**
 	 * number of threads that sleep.
 	 */
 	private int sleepers = 0;
-	
+
 	/**
 	 * constructor
-	 * @param m {@link Main}
+	 * 
+	 * @param m
+	 *            {@link Main}
 	 * 
 	 */
-	public Round(Main m)
-	{
+	public Round(Main m) {
 		this.m = m;
 	}
 
 	/**
-	 * go to the next round if all particles are in the queue
-	 * (not currently being updated by a thread), wait otherwise
-	 * we check if everything is in the queue by checking if 
-	 * every thread is sleeping except this one.
-	 * @param nextroundnr 
+	 * we wrap the poll call for the queue first to get k number of particles
+	 * instead of just one second to be able to block the threads if there are
+	 * no particles left this round the second reason is to make sure that the
+	 * first n threads get k particles instead of the possibility that none of
+	 * the threads get k particles
+	 * 
+	 * @return
 	 */
-	public synchronized void nextRound(int nextroundnr) {
-		
-		//if a thread wakes up it is possible that it still wants to check the round
-		//this way we tell it that doesnt need to increase the round nr
-		if(round == nextroundnr)
-		{
-			return;
+	public synchronized Collection<Particle> poll() {
+		// create an workingset and iterate over k until we have enough
+		// particles
+		Collection<Particle> workingset = new LinkedList<Particle>();
+		for (int i = m.getK(); i > 0; i--) {
+			Particle p = m.q.poll();
+
+			// check if its null add to the queue otherwise
+			if (p != null) {
+				workingset.add(p);
+				Main.debug("got particle" + p);
+			}
 		}
-		
-		//check if we are the last thread awake and bump the round
-		//we also need to wake everyone up
-		if (sleepers+1 == m.tpool.size()) {
-			round++;
-			notifyAll();
-			Main.debug("================= Round " + round + " ====================");
-		//to bad, not the last one we count ourself as sleeper and go sleep
-		} else {
-			Main.debug("-------------- Just wait a bit! --------------------");
-			
-			//increment the sleepers count
-			sleepers++;
-			try {
-				wait();
-			} catch (InterruptedException e) {}
-			//we are done sleeping
-			sleepers--;
+
+		// If the workingset is empty then we are at the end of the round since
+		// the queue won't give any particles
+		if (workingset.isEmpty()) {
+			// check if we are the last thread awake and bump the round
+			// we also need to wake everyone up
+			if (sleepers + 1 == m.tpool.size()) {
+				round++;
+				notifyAll();
+				Main.debug("================= Round " + round
+						+ " ====================");
+			} else {
+				// to bad, not the last one we count ourself as sleeper and go
+				// sleep
+				// increment the sleepers count
+				sleepers++;
+				Main.debug("----------------- Sleeping a bit ----------------");
+				try {
+					wait();
+				} catch (InterruptedException e) {
+				}
+				// we are done sleeping
+				sleepers--;
+
+				// try again since we are in the next round
+				Collection<Particle> ret = poll();
+				return ret;
+			}
 		}
+
+		return workingset;
 	}
 
 	/**
 	 * return the roundnumber so we can use it
+	 * 
 	 * @return
 	 */
 	public int getRoundNumber() {
Index: src/gdp/erichiram/partsim/Animation.java
===================================================================
--- src/gdp/erichiram/partsim/Animation.java	(revision 95)
+++ src/gdp/erichiram/partsim/Animation.java	(working copy)
@@ -5,7 +5,6 @@
 package gdp.erichiram.partsim;
 
 import java.util.Collection;
-import java.util.LinkedList;
 
 /**
  * Worker thread which updates the particles 
@@ -40,18 +39,8 @@
 	public void run() {
 		Collection<Particle> workingset;
 		
-		while (run) {			
-			//create an workingset and iterate over k until we have enough particles
-			workingset = new LinkedList<Particle>();
-			for (int i = main.getK(); i > 0; i--) {
-				Particle p = main.q.poll();
-				
-				//check if its null add to the queue otherwise
-				if (p != null) {
-					workingset.add(p);
-					Main.debug("got particle" + p);
-				}
-			}
+		while (run) {
+			workingset = main.round.poll();
 			
 			//iterate over the particles to do the moves
 			for (Particle current : workingset) {
@@ -64,15 +53,9 @@
 				}
 			}
 
-			//save the round number for the next round
-			int nextroundnr = main.round.getRoundNumber()+1;
 			
 			main.q.addAll(workingset);
 			Main.debug("done working on particles");
-			
-			//call for next round if we didn't get k particles
-			if (main.getK() > workingset.size())
-				main.round.nextRound(nextroundnr);
 		}
 		
 		//where finished, do cleanup
Index: patch.patch
===================================================================
--- patch.patch	(revision 95)
+++ patch.patch	(working copy)
@@ -1,269 +0,0 @@
-### Eclipse Workspace Patch 1.0
-#P Particle Simulator
-Index: src/gdp/erichiram/partsim/Round.java
-===================================================================
---- src/gdp/erichiram/partsim/Round.java	(revision 91)
-+++ src/gdp/erichiram/partsim/Round.java	(working copy)
-@@ -4,76 +4,98 @@
- 
- package gdp.erichiram.partsim;
- 
-+import java.util.Collection;
-+import java.util.LinkedList;
-+
- /**
-- * Keeps track of the rounds to make sure that threads do go 
-- * to the next while there is work to be done in this one
-- *
-+ * Keeps track of the rounds to make sure that threads do go to the next while
-+ * there is work to be done in this one
-+ * 
-  */
- public class Round {
--	
-+
- 	/**
- 	 * the round number
- 	 */
- 	private volatile int round = Main.initialRound;
--	
-+
- 	/**
- 	 * reference to main
- 	 */
- 	private final Main m;
--	
-+
- 	/**
- 	 * number of threads that sleep.
- 	 */
- 	private int sleepers = 0;
--	
-+
- 	/**
- 	 * constructor
--	 * @param m {@link Main}
-+	 * 
-+	 * @param m
-+	 *            {@link Main}
- 	 * 
- 	 */
--	public Round(Main m)
--	{
-+	public Round(Main m) {
- 		this.m = m;
- 	}
- 
-+	
- 	/**
--	 * go to the next round if all particles are in the queue
--	 * (not currently being updated by a thread), wait otherwise
--	 * we check if everything is in the queue by checking if 
--	 * every thread is sleeping except this one.
--	 * @param nextroundnr 
-+	 * we wrap the poll call for the queue
-+	 * first to get k number of particles instead of just one
-+	 * second to be able to block the threads if there are no particles left this round
-+	 * the second reason is to make sure that the first n threads get k particles 
-+	 * instead of the possibility that none of the threads get k particles
-+	 * @return
- 	 */
--	public synchronized void nextRound(int nextroundnr) {
--		
--		//if a thread wakes up it is possible that it still wants to check the round
--		//this way we tell it that doesnt need to increase the round nr
--		if(round == nextroundnr)
--		{
--			return;
-+	public synchronized Collection<Particle> poll() {
-+		// create an workingset and iterate over k until we have enough
-+		// particles
-+		Collection<Particle> workingset = new LinkedList<Particle>();
-+		for (int i = m.getK(); i > 0; i--) {
-+			Particle p = m.q.poll();
-+
-+			// check if its null add to the queue otherwise
-+			if (p != null) {
-+				workingset.add(p);
-+				Main.debug("got particle" + p);
-+			}
- 		}
- 		
--		//check if we are the last thread awake and bump the round
--		//we also need to wake everyone up
--		if (sleepers+1 == m.pool.size()) {
--			round++;
--			notifyAll();
--			Main.debug("================= Round " + round + " ====================");
--		//to bad, not the last one we count ourself as sleeper and go sleep
--		} else {
--			Main.debug("-------------- Just wait a bit! --------------------");
--			
--			//increment the sleepers count
--			sleepers++;
--			try {
--				wait();
--			} catch (InterruptedException e) {}
--			//we are done sleeping
--			sleepers--;
-+		//If the workingset is empty then we are at the end of the round since the queue won't give any particles
-+		if (workingset.isEmpty()) {
-+			// check if we are the last thread awake and bump the round
-+			// we also need to wake everyone up
-+			if (sleepers + 1 == m.tpool.size()) {
-+				round++;
-+				notifyAll();
-+				Main.debug("================= Round " + round
-+						+ " ====================");
-+			} else {
-+				// to bad, not the last one we count ourself as sleeper and go
-+				// sleep
-+				// increment the sleepers count
-+				sleepers++;
-+				Main.debug("----------------- Sleeping a bit ----------------");
-+				try {
-+					wait();
-+				} catch (InterruptedException e) {}
-+				// we are done sleeping
-+				sleepers--;
-+				
-+				//try again since we are in the next round
-+				Collection<Particle> ret = poll();
-+				return ret;
-+			}
- 		}
-+
-+		return workingset;
- 	}
- 
- 	/**
- 	 * return the roundnumber so we can use it
-+	 * 
- 	 * @return
- 	 */
- 	public int getRoundNumber() {
-Index: src/gdp/erichiram/partsim/Animation.java
-===================================================================
---- src/gdp/erichiram/partsim/Animation.java	(revision 91)
-+++ src/gdp/erichiram/partsim/Animation.java	(working copy)
-@@ -5,7 +5,6 @@
- package gdp.erichiram.partsim;
- 
- import java.util.Collection;
--import java.util.LinkedList;
- 
- /**
-  * Worker thread which updates the particles 
-@@ -40,18 +39,8 @@
- 	public void run() {
- 		Collection<Particle> workingset;
- 		
--		while (run) {			
--			//create an workingset and iterate over k until we have enough particles
--			workingset = new LinkedList<Particle>();
--			for (int i = main.getK(); i > 0; i--) {
--				Particle p = main.q.poll();
--				
--				//check if its null add to the queue otherwise
--				if (p != null) {
--					workingset.add(p);
--					Main.debug("got particle" + p);
--				}
--			}
-+		while (run) {
-+			workingset = main.round.poll();
- 			
- 			//iterate over the particles to do the moves
- 			for (Particle current : workingset) {
-@@ -64,19 +53,13 @@
- 				}
- 			}
- 
--			//save the round number for the next round
--			int nextroundnr = main.round.getRoundNumber()+1;
- 			
- 			main.q.addAll(workingset);
- 			Main.debug("done working on particles");
--			
--			//call for next round if we didn't get k particles
--			if (main.getK() > workingset.size())
--				main.round.nextRound(nextroundnr);
- 		}
- 		
- 		//where finished, do cleanup
--		main.pool.removeThread(this);
-+		main.tpool.removeThread(this);
- 		
- 		//there is a possibility that this is the last thread not sleeping. 
- 		//just to make sure we wake one
-Index: src/gdp/erichiram/partsim/Gui.java
-===================================================================
---- src/gdp/erichiram/partsim/Gui.java	(revision 94)
-+++ src/gdp/erichiram/partsim/Gui.java	(working copy)
-@@ -304,7 +304,7 @@
- 		spin.addChangeListener(new ChangeListener(){
- 
- 			public void stateChanged(ChangeEvent e) {
--				main.pool.setPMax(snm.getNumber().intValue());
-+				main.tpool.setPMax(snm.getNumber().intValue());
- 			}
- 			
- 		});
-@@ -369,7 +369,7 @@
- 					}
- 				}
- 				offscreenGraphics.setColor(Color.WHITE);
--				offscreenGraphics.drawString("p: "+String.valueOf(main.pool.size()), 1, 20);
-+				offscreenGraphics.drawString("p: "+String.valueOf(main.tpool.size()), 1, 20);
- 				offscreenGraphics.drawString("n: "+String.valueOf(main.particles.size()), 1, 35);
- 				g.drawImage(offscreenImage, 0, 0, this);
- 				offscreenGraphics.setColor(Color.BLACK);
-Index: src/gdp/erichiram/partsim/Main.java
-===================================================================
---- src/gdp/erichiram/partsim/Main.java	(revision 91)
-+++ src/gdp/erichiram/partsim/Main.java	(working copy)
-@@ -36,7 +36,7 @@
- 		public synchronized Particle poll(){
- 			
- 			//if peek is null or particle not in round return null
--			if(peek() == null || round.getRoundNumber() != peek().getRound())
-+			if(isEmpty() || round.getRoundNumber() != peek().getRound())
- 			{
- 				return null;
- 			}
-@@ -62,7 +62,7 @@
- 	/**
- 	 * collection of threads
- 	 */
--	protected final ThreadPool pool = new ThreadPool(this);
-+	protected final ThreadPool tpool = new ThreadPool(this);
- 	
- 	/**
- 	 * keeps track of the rounds, makes sure threads dont work on particles for next round
-@@ -103,7 +103,7 @@
- 	/**
- 	 * display debug statements
- 	 */
--	private static final boolean DEBUG = true;
-+	private static final boolean DEBUG = false;
- 		
- 	/**
- 	 * constructor
-@@ -146,7 +146,7 @@
- 	 * @see Main#t t
- 	 * @return the number
- 	 */
--	public long getT() {
-+	public int getT() {
- 		return t;
- 	}
- 
-@@ -176,7 +176,7 @@
- 	private void addParticle(Particle particle){
- 		q.offer(particle);
- 		particles.add(particle);
--		pool.update();
-+		tpool.update();
- 	}
- 
- 	/**
